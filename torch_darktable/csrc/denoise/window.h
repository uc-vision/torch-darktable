// Auto-generated separable Gaussian windows for denoising
// Generated by generate_gaussian_windows.py
// Use outer product to get 2D window: window_2d[i][j] = window_1d[i] * window_1d[j]
#pragma once
#include <tuple>
#include <torch/torch.h>
#include "../cuda_utils.h"

// 16x16 separable Gaussian windows
__constant__ float window_fft_16[16];
__constant__ float window_interp_16[16];

// 32x32 separable Gaussian windows  
__constant__ float window_fft_32[32];
__constant__ float window_interp_32[32];

// Generic helper function to initialize Gaussian windows for any size K using PyTorch
template<int K>
inline void init_windows(const void* fft_symbol, const void* interp_symbol, 
                        float weight_fft = 0.3f, float weight_interp = 0.3f, 
                        cudaStream_t stream = 0) {
    const float half = K / 2.0f;
    const float fft_scale = weight_fft * half * half;
    const float interp_scale = weight_interp * half * half;
    
    // Create coordinate tensor: r from (-half + 0.5) to (half - 0.5) 
    auto r = torch::linspace(-half + 0.5f, half - 0.5f, K, torch::dtype(torch::kFloat32).device(torch::kCUDA));
    
    // Calculate Gaussian values
    auto fft_vals = torch::exp(-(r * r) / fft_scale);
    auto interp_vals = torch::exp(-(r * r) / interp_scale);
    
    // Normalize so sum of squares = 1
    fft_vals = fft_vals / torch::norm(fft_vals);
    interp_vals = interp_vals / torch::norm(interp_vals);
    
    // Async copy to constant memory symbols
    CUDA_CHECK(cudaMemcpyToSymbolAsync(fft_symbol, fft_vals.data_ptr<float>(), 
                                       K * sizeof(float), 0, cudaMemcpyDeviceToDevice, stream));
    CUDA_CHECK(cudaMemcpyToSymbolAsync(interp_symbol, interp_vals.data_ptr<float>(), 
                                       K * sizeof(float), 0, cudaMemcpyDeviceToDevice, stream));
}

// Templated Window class
template<int K>
struct Window;

template<>
struct Window<16> {
    
    __device__ __forceinline__ static float fft_window(int2 pos) {
        return window_fft_16[pos.x] * window_fft_16[pos.y];
    }
    
    __device__ __forceinline__ static float interp_window(int2 pos) {
        return window_interp_16[pos.x] * window_interp_16[pos.y];
    }
    
    
    static inline void init(float weight_fft = 0.3f, float weight_interp = 0.3f, cudaStream_t stream = 0) {
        ::init_windows<16>(window_fft_16, window_interp_16, weight_fft, weight_interp, stream);
    }
};

template<>
struct Window<32> {
    
    __device__ __forceinline__ static float fft_window(int2 pos) {
        return window_fft_32[pos.x] * window_fft_32[pos.y];
    }
    
    __device__ __forceinline__ static float interp_window(int2 pos) {
        return window_interp_32[pos.x] * window_interp_32[pos.y];
    }
    
    
    
    static inline void init(float weight_fft = 0.3f, float weight_interp = 0.3f, cudaStream_t stream = 0) {
        ::init_windows<32>(window_fft_32, window_interp_32, weight_fft, weight_interp, stream);
    }
};

// Convenience functions
inline void init_16(float weight_fft = 0.3f, float weight_interp = 0.3f, cudaStream_t stream = 0) {
    init_windows<16>(window_fft_16, window_interp_16, weight_fft, weight_interp, stream);
}

inline void init_32(float weight_fft = 0.3f, float weight_interp = 0.3f, cudaStream_t stream = 0) {
    init_windows<32>(window_fft_32, window_interp_32, weight_fft, weight_interp, stream);
}

