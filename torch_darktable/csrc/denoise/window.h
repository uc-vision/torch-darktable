// Auto-generated separable Gaussian windows for denoising
// Generated by generate_gaussian_windows.py
// Use outer product to get 2D window: window_2d[i][j] = window_1d[i] * window_1d[j]
#pragma once
#include <tuple>

// 16x16 separable Gaussian windows
__constant__ float window_fft_16[16];
__constant__ float window_interp_16[16];

// 32x32 separable Gaussian windows  
__constant__ float window_fft_32[32];
__constant__ float window_interp_32[32];

// Generic helper function to initialize Gaussian windows for any size K
template<int K>
inline void init_windows(const void* fft_symbol, const void* interp_symbol, 
                                  float weight_fft = 0.3f, float weight_interp = 0.3f) {
    float fft_vals[K];
    float interp_vals[K];
    
    // Calculate Gaussian values using the formula
    const float half = K / 2.0f;
    const float fft_scale = weight_fft * half * half;
    const float interp_scale = weight_interp * half * half;
    
    // Compute sum of squares for normalization
    float fft_sum_sq = 0.0f;
    float interp_sum_sq = 0.0f;
    
    #pragma unroll
    for (int i = 0; i < K; ++i) {
        const float r = -half + 0.5f + i;
        fft_vals[i] = expf(-(r * r) / fft_scale);
        interp_vals[i] = expf(-(r * r) / interp_scale);
        fft_sum_sq += fft_vals[i] * fft_vals[i];
        interp_sum_sq += interp_vals[i] * interp_vals[i];
    }
    
    // Normalize so sum of squares = 1
    float fft_norm = 1.0f / sqrtf(fft_sum_sq);
    float interp_norm = 1.0f / sqrtf(interp_sum_sq);
    
    #pragma unroll
    for (int i = 0; i < K; ++i) {
        fft_vals[i] *= fft_norm;
        interp_vals[i] *= interp_norm;
    }
    
    // Copy to provided constant memory symbols
    auto err1 = cudaMemcpyToSymbol(fft_symbol, fft_vals, K * sizeof(float));
    auto err2 = cudaMemcpyToSymbol(interp_symbol, interp_vals, K * sizeof(float));
    
    if (err1 != cudaSuccess || err2 != cudaSuccess) {
        throw std::runtime_error("Failed to copy " + std::to_string(K) + "x" + std::to_string(K) + 
                                " windows to constant memory");
    }
}

// Templated Window class
template<int K>
struct Window;

template<>
struct Window<16> {
    
    __device__ __forceinline__ static float fft_window(int2 pos) {
        return window_fft_16[pos.x] * window_fft_16[pos.y];
    }
    
    __device__ __forceinline__ static float interp_window(int2 pos) {
        return window_interp_16[pos.x] * window_interp_16[pos.y];
    }
    
    
    static inline void init(float weight_fft = 0.3f, float weight_interp = 0.3f) {
        ::init_windows<16>(window_fft_16, window_interp_16, weight_fft, weight_interp);
    }
};

template<>
struct Window<32> {
    
    __device__ __forceinline__ static float fft_window(int2 pos) {
        return window_fft_32[pos.x] * window_fft_32[pos.y];
    }
    
    __device__ __forceinline__ static float interp_window(int2 pos) {
        return window_interp_32[pos.x] * window_interp_32[pos.y];
    }
    
    
    
    static inline void init(float weight_fft = 0.3f, float weight_interp = 0.3f) {
        ::init_windows<32>(window_fft_32, window_interp_32, weight_fft, weight_interp);
    }
};

// Convenience functions
inline void init_16(float weight_fft = 0.3f, float weight_interp = 0.3f) {
    init_windows<16>(window_fft_16, window_interp_16, weight_fft, weight_interp);
}

inline void init_32(float weight_fft = 0.3f, float weight_interp = 0.3f) {
    init_windows<32>(window_fft_32, window_interp_32, weight_fft, weight_interp);
}

